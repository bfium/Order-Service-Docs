{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome the Order Service-Documentations","text":""},{"location":"blog/","title":"Service-Oriented (Microservice) Archictecture","text":""},{"location":"blog/#order-service-restfull-api","title":"Order Service RESTfull API","text":"<p>Representational state transfer (REST) describes an architectural style for applica- tions that communicate over a network.  Originally, the concept of REST included a list of constraints for the design of distributed and scalable web applications.  Over time, detailed protocols and specifications have emerged that give us well-defined guidelines for designing REST APIs. </p> <p>DEFINITION: REST is an architectural style for building loosely coupled and highly scalable APIs. REST APIs are structured around resources, entities that can be manipulated through the API.</p> <p>Using the Database-per-service principle, which state that each microservice owns a specific set of the data, and no other service should have have access to such data except through an API.</p> <p>The Online Shopping System case study is a highly distributed World Wide Web\u2013 based system  that provides services for purchasing items such as cafes or cafe related utilities.  The solution uses a service-oriented architecture with <code>multiple services</code>;  <code>coordinator objects</code> are used to facilitate the integration of the services.  In addition, object brokers are used to provide service registration, brokering, and discovery. </p>"},{"location":"blog/author/barth_feudong/","title":"The Material Team","text":"<p>A small group of people dedicated to making writing documentation easy, if not outright fun! Here are some of the things we have blogged about:</p>"},{"location":"blog/2024/08/11/architectural-constraints-of-rest-applications/","title":"Architectural constraints of REST applications","text":"<p>These constraints were enumerated by Fielding, and they specify how a server should process and respond to a client request.</p> <ul> <li><code>Client-server architecture</code>: The user interface (UI) must be decoupled from the backend.</li> <li><code>Statelessness</code>: The server must not manage states between requests.</li> <li><code>Cacheability</code>: Requests that always return the same response must be cacheable.</li> <li><code>Layered system</code>: The API may be architected in layers, but such complexity must be hidden from the user(Using the Coordinator pattern).</li> <li><code>Code on demand</code>: The server can inject code into the user interface on demand.</li> <li><code>Uniform interface</code>: The API must provide a consistent interface for accessing and manipulating resources.</li> </ul>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/architectural-constraints-of-rest-applications/#the-client-server-architecture-principle","title":"The client-server architecture principle","text":"<p>REST relies on the principle of separation of concerns, and consequently it requires that user interfaces are decoupled from data storage and server logic.  This allows server-side components to evolve independently from UI elements.</p>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/architectural-constraints-of-rest-applications/#the-statelessness-principle","title":"The statelessness principle","text":"<p>In REST, every request to the server must contain all the information necessary to pro- cess it. In particular, the server must not keep state from one request to the next. removing state management from server components makes it easier to scale the backend horizontally.  This allows us to deploy multiple instances of the server, and because none of those instances manages the API client\u2019s state, the client can communicate with any of them.</p>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/architectural-constraints-of-rest-applications/#the-cacheability-principle","title":"The cacheability principle","text":"<p>When applicable, server responses must be cached.  Caching improves the performance of APIs because it means we don\u2019t have to perform all the calculations required to serve a response again and again. </p> <p><code>GET</code> requests are suitable for caching, since they return data already saved in the server.</p> <p>by caching a GET request, we avoid having to fetch data from the source every time a user requests the same information.  The longer it takes to assemble the response for a GET request, the greater the benefits of caching it.</p> <p>The orders service interfaces with the kitchen service to obtain information on the order\u2019s progress.  To save time the next time the customer checks the order\u2019s status, we cache its value for a short period of time.</p>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/architectural-constraints-of-rest-applications/#the-layered-system-principle","title":"The layered system principle","text":"<p>In a REST architecture, clients must have a unique point of entry to your API and must not be able to tell whether they are connected directly to the end server or to an intermediary layer such as a load balancer.  You can deploy different components of a server-side application in different servers, or you can deploy the same component across different servers for redundancy and scalability.  This complexity should be hidden from the user by exposing a single endpoint that encapsulates access to your services.</p>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/architectural-constraints-of-rest-applications/#the-code-on-demand-principle","title":"The code-on-demand principle","text":"<p>Servers can extend the functionality of a client application by sending executable code directly from the backend, such as JavaScript files needed to run a UI.  This constraint is optional and only applies to applications in which the backend serves the client interface.</p>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/architectural-constraints-of-rest-applications/#the-uniform-interface-principle","title":"The uniform interface principle","text":"<p>REST applications must expose a uniform and consistent interface to their consumers.  The interface must be documented, and the API specification must be followed strictly by the server and the client.  Individual resources are identified by a Uniform Resource Identifier (URI),4 and each URI must be unique and always return the same resource. </p> <p>For example, the URI /orders/8 represents an order with ID 8, and a GET request on this URI always returns the state of the order with ID 8.  If the order is deleted from the system, the ID must not be reused to represent a different order.</p>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/designing-api-payloads/","title":"Designing API payloads","text":"<p>Payloads represent the data exchanged between a client and a server through an HTTP request.  We send payloads to the server when we want to cre- ate or update a resource, and the server sends us payloads when we request data.  The usability of an API is very much dependent on good payload design.</p>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/designing-api-payloads/#response-payloads-for-post-requests","title":"RESPONSE PAYLOADS FOR POST REQUESTS","text":"<p>We use POST requests to create resources. </p> <p>We place orders through the <code>POST/orders</code> endpoint.  with the following payload:</p> <pre><code> {\n  \"order\": [\n     {\n      \"product\": \"cappuccino\",\n      \"size\": \"big\",\n      \"quantity\": 1\n    }, \n    {\n      \"product\": \"croissant\",\n      \"size\": \"medium\",\n      \"quantity\": 2\n    }\n  ]\n}\n</code></pre> <p>To place an order, we send the list of items we want to buy to the server, which takes responsibility for:</p> <ul> <li>assigning a unique ID to the order, </li> <li> <p>sets the time when the order was taken and its initial status. </p> </li> <li> <p>therefore the order\u2019s ID must be returned in the response payload: </p> </li> </ul> <pre><code>{\n  \"id\": \"96247264-7d42-4a95-b073-44cedf5fc07d\", \n  \"created\": \"2024-02-02\",\n  \"status\": \"created\",\n  \"order\": [\n     {\n      \"product\": \"cappuccino\",\n      \"size\": \"big\",\n      \"quantity\": 1\n    }, \n    {\n      \"product\": \"croissant\",\n      \"size\": \"medium\",\n      \"quantity\": 2\n    }\n  ] \n}\n</code></pre> <p>We call the properties set by the server server-side or read-only properties, and we must include them in the response payload.</p>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/designing-api-payloads/#response-payloads-for-put-and-patch-requests","title":"RESPONSE PAYLOADS FOR PUT AND PATCH REQUESTS","text":"<p>To update a resource, we use a PUT or a PATCH request.</p> <p>we make use of the PUT /orders/ {order_id}  (<code>like PUT /orders/cf979f89-effd-4996-ae3d-8d42c79e0831</code>) endpoint of the orders API with the following payload:</p> <pre><code>{\n  \"id\": \"cf979f89-effd-4996-ae3d-8d42c79e0831\", \n  \"created\": \"2024-02-02\",\n  \"status\": \"created\",\n  \"order\": [\n    {\n      \"product\": \"cappuccino\",\n      \"size\": \"big\",\n      \"quantity\": 1\n    }, \n    {\n      \"product\": \"croissant\",\n      \"size\": \"medium\",\n      \"quantity\": 2\n    }\n  ] \n}\n</code></pre> <p>the service the return a full representation of the resource, which the client can use to validate that the update was correctly processed.</p> <pre><code> {\n  \"id\": \"cf979f89-effd-4996-ae3d-8d42c79e0831\",\n  \"created\": \"2024-02-02\",\n  \"status\": \"created\",\n  \"order\": [\n    {\n      \"product\": \"cappuccino\",\n      \"size\": \"big\",\n      \"quantity\": 1\n    }, \n    {\n      \"product\": \"croissant\",\n      \"size\": \"medium\",\n      \"quantity\": 2\n    }\n  ]\n}\n</code></pre>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/designing-api-payloads/#response-payloads-for-get-requests","title":"RESPONSE PAYLOADS FOR GET REQUESTS","text":"<p>We retrieve resources from the server using GET requests. The orders API exposes two GET endpoints:</p> <ul> <li>GET /orders  The GET /orders returns a list of orders. </li> </ul> <p><code>Strategie1</code>: include a full representation of each order </p> <pre><code>{\n  \"orders\": [\n  {\n    \"id\": \"96247264-7d42-4a95-b073-44cedf5fc07d\", \n    \"created\": \"2025-02-02\",\n    \"status\": \"created\",\n    \"order\": [\n      {\n      \"product\": \"cappuccino\",\n      \"size\": \"big\",\n      \"quantity\": 1\n    }, \n    {\n      \"product\": \"croissant\",\n      \"size\": \"medium\",\n      \"quantity\": 2\n    }\n    ]\n  },\n    {\n     \"id\": \"96877264-7d42-4a95-b073-44cedjf5fc07d\", \n    \"created\": \"2024-02-02\",\n    \"status\": \"created\",\n    \"order\": [\n    {\n      \"product\": \"expresso\",\n      \"size\": \"small\",\n      \"quantity\": 2\n    }, \n    {\n      \"product\": \"burger\",\n      \"size\": \"big\",\n      \"quantity\": 3\n    }\n  ]\n}\n  ]\n}\n</code></pre> <p><code>Strategie2</code>: include a partial representation of each order.</p> <pre><code>{\n  \"orders\": [\n  {\n    \"id\": \"cf979f89-effd-4996-ae3d-8d42c79e0831\"\n  }, \n    {\n      \"id\": \"f005db16-fa8c-4e29-82a6-6210dddda554\"\n  }\n  ]\n}\n</code></pre> <p>when using the GET /orders endpoint, we may want to limit the results to only the five most recent orders or to list only cancelled orders.  URL query parameters allow us to accomplish those goals and should always be optional, and, when appropriate, the server may assign default values for them. GET /orders?cancelled=true GET /orders?cancelled=true&amp;Limit=5</p> <ul> <li>GET /orders/{orders_id} with order_id= <code>cf979f89-effd-4996-ae3d-8d42c79e0831</code> The payload of the response will be: </li> </ul> <pre><code> {\n  \"id\": \"cf979f89-effd-4996-ae3d-8d42c79e0831\",\n  \"created\": \"2024-02-02\",\n  \"status\": \"created\",\n  \"order\": [\n    {\n      \"product\": \"cappuccino\",\n      \"size\": \"big\",\n      \"quantity\": 1\n    }, \n    {\n      \"product\": \"croissant\",\n      \"size\": \"medium\",\n      \"quantity\": 2\n    }\n  ]\n}\n</code></pre>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/requirements/","title":"Requirements","text":"<p>about the requirements of the Online shopping </p> <p>\u25a0 Loose coupling.  Services should be relatively independent of each other. Thus, a service should hold a minimum amount of information about other services and ideally should not depend on other services.</p> <p>\u25a0 Service contract.  A service provides a contract, which a SOA application can rely on. The contract is typically defined in the service interface in the form of a set of operations. Each operation usually has input and output parameters, but it can also include quality of service parameters such as response time and availabil- ity. This principle builds on the object-oriented design concept of separating the interface and the implementation, and establishing the interface as the contract between the provider of the service and the user of the service.</p> <p>\u25a0 Autonomy.  Each service is self-contained, such that it can operate independently without the need of other services. This concept can be achieved by separating services from coordination, so that services do not directly communicate with each other.</p> <p>\u25a0 Abstraction.  As with object-oriented design, the details of a service are hidden, A service only reveals its interface in terms of the operations it provides, and for each operation, the inputs it needs, and the outputs it returns.</p> <p>\u25a0 Reusability.  A key goal of SOA is to design services that are reusable. The pre- ceding design goals of services are intended to facilitate reuse.</p> <p>\u25a0 Composability.  Services are designed to be capable of being assembled into larger composite services. In some cases, a composite service also needs to pro- vide coordination of the individual services.</p> <p>\u25a0 Statelessness.  Where possible, services maintain little or no information about specific client activities.</p> <p>\u25a0 Discoverability.  A service provides an external description to help allow it to be discovered by a discovery mechanism.</p>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/requirements/#protocols","title":"Protocols","text":"","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/requirements/#web-services-protocols","title":"Web services protocols","text":"<p>Application clients and services need to have a communication protocol for inter- component communication. Extensible Markup Language (XML) is a technology that allows different systems to interoperate through exchange of data and text. The Simple Object Access Protocol (SOAP), which is a lightweight protocol developed by the World Wide Web Consortium (W3C), builds on XML and HTTP to per- mit exchange of information in a distributed environment. SOAP defines a unified approach for sending XML-encoded data and consists of three parts: an envelope that defines a framework for describing what is in a message and how to process it, a set of encoding rules for expressing instances of application-defined data types, and a convention for representing remote procedure calls and responses.</p>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/requirements/#web-services","title":"Web Services","text":"<p>Applications provide services for clients. One example of application services is Web services, which use the World Wide Web for application-to-application com- munication. From a software perspective, Web services are the application program- ming interfaces (APIs) that provide a standard means of communication among dif- ferent software applications on the World Wide Web. From a business application perspective, a Web service is business functionality provided by a company in the form of an explicit service over the Internet for other companies or programs to use. A Web service is provided by a service provider and may be composed of other ser- vices to form new services and applications. An example of a Web client invoking a Web service is given in Figure 16.5.</p>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/securing-the-api/","title":"Securing the API","text":"<p>If our API is protected, the API specification must describe how users need to authenticate and authorize their requests.</p> <p>The security definitions of the API go within the components section of the specification, under the securitySchemes header.</p> <p>With OpenAPI, we can describe different security schemes, such as:</p> <ul> <li>HTTP-based authentication, </li> <li>key-based authentication, </li> <li>Open Authorization 2 (OAuth2),  </li> <li>OpenID Connect.</li> </ul> <pre><code>components:\n  responses:\n    #...\n  schemas:\n    #...\n  securitySchemes:  # The security schemes under the securitySchemes header of the API\u2019s components section\n    openId:   # We provide a name for the security scheme (it can be any name).\n      type: openIdConnect   # The type of security scheme\n      openIdConnectUrl: https://order-service-dev.eu.auth0.com/.well-known/openid-configuration # The URL that describes the OpenID Connect configuration in our backend\n    oauth2:   # The name of another security scheme\n      type: oauth2   # The type of the security scheme\n      flows:      # The authorization flows available under this security scheme\n        clientCredentials: # A description of the client credentials flow\n          tokenUrl: https://order-service-dev.eu.auth0.com/oauth/token # The URL where users can request authorization tokens\n            scopes:{}     # The available scopes when requesting an authorization token\n    bearerAuth:\n      type: http\n      sheme: bearer\n      bearerFormat: JWT  # The bearer token has a JSON Web Token (JWT) format.\n\n  security:\n  - oauth2:\n      - getOrders\n      - createOrder\n      - getOrder\n      - updateOrder\n      - deleteOrder\n      - payOrder\n      - cancelOrder\n  - bearerAuth:\n      - getOrders\n      - createOrder\n      - getOrder\n      - updateOrder\n      - deleteOrder\n      - payOrder\n      - cancelOrder\n\n</code></pre>"},{"location":"blog/2024/08/11/using-openapi-as-specifications-for-the-orders-api/","title":"Using OpenAPI as specifications for the Order's API","text":"","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/using-openapi-as-specifications-for-the-orders-api/#post-orders","title":"POST /orders","text":"<pre><code>paths:\n  /oders:\n    post:\n      summary: Create an order\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/CreateOrderRequestSchema'\n      responses:\n        '201':\n          description: A JSON representation of the created order\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/OrderResponseSchema'\n        '422':\n          description: unprocessable entity\n\ncomponents:\n  schemas:\n    OrderItemSchema:\n      description: order item schema\n      additionalProperties: false\n      type: object\n      required:\n        - product\n        - size\n      properties:\n        product:\n          type: string\n        size:\n          type: string\n          enum:\n            - small\n            - medium\n            - big\n        quantity:\n          type: integer\n          format: int64\n          default: 1\n          minimum: 1\n          maximum: 1000000\n\n    CreateOrderRequestSchema:\n      description: create order schema\n      additionalProperties: false\n      type: object\n      required:\n        - order\n      properties:\n        order:\n          type: array\n          minItems: 1\n          items:\n            $ref: '#/components/schemas/OrderItemSchema'\n\n    OrderResponseSchema:\n      description: the schema of the response of the order request\n      additionalProperties: false\n      type: object\n      required:\n        - id\n        - created\n        - status\n        - order\n      properties:\n        id:\n          type: string\n          format: uuid\n        created:\n          type: string\n          format: data-time\n        status:\n          type: string\n          enum:\n            - created\n            - paid\n            - progress\n            - cancelled\n            - dispatched\n            - delivered\n        order:\n          type: array\n          minItems: 1\n          items:\n            $ref: '#/components/schemas/OrderItemSchema'\n\n</code></pre>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/structured-resource-urls-with-http-methods/","title":"Structured resource URLs with HTTP methods","text":"<p>We use HTTP methods in combination with URLs.</p>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/structured-resource-urls-with-http-methods/#how-do-we-use-http-methods-to-define-the-endpoints-of-the-orders-api","title":"How do we use HTTP methods to define the endpoints of the orders API?","text":"<p>HTTP methods are special keywords used in HTTP requests to indicate the type of action we want to perform in the server.  Proper use of HTTP methods makes our APIs more structured and elegant, and since they\u2019re part of the HTTP protocol, they also make the API more understandable and easier to use.</p> <p>The most relevant HTTP methods in REST APIs are GET, POST, PUT, PATCH, and DELETE:</p> <ul> <li>GET\u2014Returns information about the requested resource </li> <li>POST\u2014Creates a new resource</li> <li>PUT\u2014Performs a full update by replacing a resource</li> <li>DELETE\u2014Deletes a resource</li> </ul> <p>In the orders API, we have these two resource URLs:</p> <ul> <li><code>/orders</code>: Represents a list of orders. </li> <li><code>/orders/{orders_id}</code>: Represents a single order.  The curly braces around {order_id} indicates that this is a URL path parameter and must be replaced by the ID of an order.</li> </ul> <p>we use the singleton URL /orders/{order_id} to per- form actions on an order, such as updating it, and the collections URL /orders to place and to list past orders. HTTP methods help us model these operations:</p> <ul> <li>POST /orders to place orders since we use POST to create new resources. </li> <li>GET /orders to retrieve a list of orders since we use GET to obtain information. </li> <li>GET /orders/{order_id} to retrieve the details of a particular order. </li> <li>PUT /orders/{order_id} to update an order since we use PUT to update a resource. </li> <li>DELETE /orders/{order_id} to delete an order since we use DELETE for deletes. </li> <li>POST /orders/{order_id}/cancel to cancel an order. We use POST to create a cancellation. </li> <li>POST /orders/{order_id}/pay to pay for an order. We use POST to create a payment.</li> </ul>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/structured-resource-urls-with-http-methods/#using-http-status-codes-to-create-expressive-http-responses","title":"Using HTTP status codes to create expressive HTTP responses","text":"<p>We use status codes to signal the result of processing a request in the server. Status codes fall into the following five groups:</p> <ul> <li>1xx group\u2014Signals that an operation is in progress </li> <li>2xx group\u2014Signals that a request was successfully processed </li> <li>3xx group\u2014Signals that a resource has been moved to a new location </li> <li>4xx group\u2014Signals that something was wrong with the request </li> <li>5xx group\u2014Signals that there was an error while processing the request</li> </ul>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/structured-resource-urls-with-http-methods/#successful-http-status-codes-for-the-order-service","title":"Successful HTTP status codes for the Order Service","text":"<ul> <li>POST /orders: 201 (Created)\u2014Signals that a resource has been created. </li> <li>GET /orders: 200 (OK)\u2014Signals that the request was successfully processed. </li> <li>GET /orders/{order_id}: 200 (OK)\u2014Signals that the request was successfully processed. </li> <li>PUT /orders/{order_id}: 200 (OK)\u2014Signals that the resource was successfully updated. </li> <li>DELETE /orders/{order_id}: 204 (No Content)\u2014Signals that the request was successfully processed but no content is delivered in the response.  Contrary to all other methods, a DELETE request doesn\u2019t require a response with payload</li> <li>POST /orders/{order_id}/cancel: 200 (OK)\u2014Although this is a POST endpoint, we use the 200 (OK) status code since we\u2019re not really creating a resource, and all the client wants to know is that the cancellation was successfully processed. </li> <li>POST /orders/{order_id}/pay: 200 (OK)\u2014Although this is a POST endpoint, we use the 200 (OK) status code since we\u2019re not really creating a resource, and all the client wants to know is that the payment was successfully processed.</li> </ul>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/structured-resource-urls-with-http-methods/#unsuccessful-http-status-codes-for-the-order-service","title":"Unsuccessful HTTP status codes for the Order Service","text":"<p>We distinguish two groups of errors:</p> <ul> <li>Errors made by the user when sending the request, for example, due to a malformed payload, or due to the request being sent to a nonexistent endpoint. We address this type of error with an HTTP status code in the 4xx group. </li> <li>Errors unexpectedly raised in the server while processing the request, typically due to a bug in our code. We address this type of error with an HTTP status code in the 5xx group.</li> </ul>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/structured-resource-urls-with-http-methods/#using-http-status-codes-to-report-client-errors-in-the-request","title":"Using HTTP status codes to report client errors in the request","text":"<p>Payloads with invalid syntax are payloads that the server can neither parse nor under- stand. A typical example of a payload with invalid syntax is malformed JSON.</p> <ul> <li>we address this type of error with a 400 (Bad Request) status code.</li> </ul> <p>Unprocessable entities are syntactically valid payloads that miss a required parameter, contain invalid parameters, or assign the wrong value or type to a parameter.</p> <ul> <li>We address this type of error with the 422 (Unprocessable Entity) status code, which signals that something was wrong with the request and it couldn\u2019t be processed.</li> </ul> <p>If a client uses that endpoint with a nonexistent order ID, we should respond with an HTTP status code signaling that the order doesn\u2019t exist.</p> <ul> <li>we address this error with the 404 (Not Found) status code, which signals that the requested resource is not available or couldn\u2019t be found.</li> </ul> <p>if a user sent a PUT request on the /orders endpoint, we must tell them that the PUT method is not supported on that URL path. There are two HTTP status codes we can use to address this situation. </p> <ul> <li>we can return a 501 (Not Implemented) if the method hasn\u2019t been implemented but will be available in the future (i.e., we have a plan to implement it).</li> <li>If the requested HTTP method is not available, and we don\u2019t have a plan to implement it, we respond with the 405 (Method Not Allowed) status code</li> </ul> <p>Two common errors in API requests have to do with authentication and authorization. The first happens when a client sends an unauthenticated request to a protected endpoint. In that case, we must tell them that they should first authenticate.</p> <ul> <li>we address this situation with the 401 (Unauthorized) status code, which signals that the user hasn\u2019t been authenticated.</li> </ul> <p>The second error happens when a user is correctly authenticated and tries to use an endpoint or a resource they are not authorized to access. An example is a user trying to access the details of an order that doesn\u2019t belong to them. </p> <ul> <li>we address this scenario with the 403 (Forbidden) status code, which signals that the user doesn\u2019t have permissions to access the requested resource or to perform the requested operation.</li> </ul>","tags":["new year","hogmanay"]},{"location":"blog/2024/08/11/structured-resource-urls-with-http-methods/#using-http-status-codes-to-report-errors-in-the-server","title":"Using HTTP status codes to report errors in the server","text":"<p>when our application crashes unexpectedly due to a bug. </p> <ul> <li>we respond with a 500 (Internal Server Error) status code</li> </ul> <p>when the server is unable to take on new connections, </p> <ul> <li>we must respond with a 503 (Service Unavailable) status code, which signals that the server is overloaded or down for maintenance and therefore cannot service additional requests.</li> </ul>","tags":["new year","hogmanay"]},{"location":"blog/archive/2024/","title":"Aug 2024","text":""},{"location":"blog/category/it/","title":"it","text":""},{"location":"blog/page/2/","title":"Service-Oriented (Microservice) Archictecture","text":""},{"location":"blog/archive/2024/page/2/","title":"Aug 2024","text":""}]}